.mixin bookish

.copy basic.css

<body bgcolor=#f4f4ff>

.h1 RubyText

RubyText is a curses wrapper. The modern variant is ncurses, and there are also 
others. This tutorial doesn't cover much of "real" curses, as the aim is to 
wrap it and make it simpler.

This project is somewhat in its infancy. Once it is a little more mature, I
hope to produce an Elixir version. (Elixir is not usually used at the desktop,
but it _can be.)

.def example
   arg = _args.first
   file = arg + ".rb.html"
   sshot = arg + ".png"
   code = File.read(file)  # HTML from vim
   lines = code.split("\n")
   n0 = lines.find_index {|x| x =~ /^<pre/ }
   n1 = lines.find_index {|x| x =~ /^<.pre>/ }
   nlines = n1 - n0 - 1
# hw.png PNG 283x190 283x190+0+0 8-bit sRGB 5443B 0.000u 0:00.000
   img_data = `identify #{sshot}`  # depends on imagemagick
   wimg, himg = img_data.split[2].split("x")
   wide = wimg.to_i * 2
   high = himg.to_i + 25
   hmax = [high, nlines*20].max  # Code may be longer than screenshot height
   _puts "<!-- high = #{high}   nlines*20 = #{nlines*20} -->"
   File.open("wrap-#{arg}.html", "w") do |f|
     f.puts "<table width=100% cellpadding=2><tr><td width=50% valign=top>"
     f.puts code
     f.puts "</td><td valign=top><img src=#{sshot} valign=top></td></tr></table>"
   end
   _puts <<-HTML
     <iframe frameborder=0 
             width=#{wide} height=#{hmax} 
             src='wrap-#{arg}.html'>
     </iframe>
   HTML
.end

Let's start at the beginning with the overused "hello world" example.

.example hw

Here are some things to notice:
.list
Obviously you have to require the `rubytext library.
You have to invoke `RubyText.start (possibly with parameters).
When the curses environment is started, things like `puts are overridden.
We call `getch here (get a character) to make the program "pause" so as not to exit before we see anything.
At program exit, your screen will be restored to normal.
.end

Here's another example.

.example stdscr

.h3 The start method

The `start method can take a number of parameters, some of which
are keyword arguments. If you know curses, some of these will be familiar,
while others provide functionality unrelated to what curses provides.

.dlist |
`:cbreak|Like `cbreak in curses. Inverse is `:\_cbreak (preferred) or `:nocbreak
`:raw|Like `raw in curses. Inverse is `:\_raw (preferred) or `:noraw
`:echo|Like `echo in curses. Inverse is `:\_echo (preferred) or `:noecho
`:keypad|Like `keypad in curses. Inverse is `:\_keypad (preferred) or `:nokeypad
`log: _logfile|Log debugging information to specified file.
`fg: _foreground|Set foreground color for STDSCR.
`bg: _background|Set background color for STDSCR.
`scroll: _Boolean|Permit (or disallow) window scrolling for STDSCR.
.end


The defaults are as follows: 

.mono
  RubyText.start(:cbreak, :_raw, :_echo, :keypad, log: "/tmp/rubytext.log",
                 fg: White, bg: Blue, scroll: true)

  # can be abbreviated simply:

  RubyText.start
.end

If you're a relative curses newbie (like me), you may have some confusion about
the `cbreak and `raw modes.

[TBD explanation]

.table
`cbreak :: NO buffering or line editing :: Permits interrupts (^C, ^Z, ...) :: Overrides `raw
`raw :: NO buffering or line editing :: No interrupts (read as characters) :: 
.end

That's all for now.

.comment
MODE             buffering?         erase/kill?    IQSF   NOTES

cbreak           no                 no             yes    cbreak overrides raw.
_cbreak          yes                yes            yes
raw              no                 no             no     reads: interrupt, quit, suspend, flow control 

Defaults: cbreak, _echo, keypad

cbreak routine disables line buffering and erase/kill character-processing 
(interrupt and flow control characters are unaffected), making characters 
typed by the user immediately available to the program. 

nocbreak returns the terminal to normal (cooked) mode.

A program should call cbreak or nocbreak explicitly. 
Most interactive programs using curses set the cbreak mode. 
Note that cbreak overrides raw.

The echo and noecho routines control whether characters are echoed by getch
Echoing by the tty driver is always disabled, but initially getch is in echo mode.

most interactive programs disable echoing 

keypad option enables keypad of user's terminal. 
User can press a function key (e.g. arrow) and getch returns a single 
value e.g. KEY_LEFT. 

Skip for now: 
halfdelay 
intrflush option 

Skip?
nodelay causes getch to be a non-blocking call. 
If no input is ready, getch returns ERR.

Skip?
notimeout(win, TRUE) -- wgetch does not set a timer. 
Differentiate between sequences received from a function key and those typed by a user.

raw and noraw -- 
Raw mode is similar to cbreak mode -- characters typed are immediately passed through.
Differences: in raw mode -- the interrupt, quit, suspend, and flow control characters 
are all passed through uninterpreted, instead of generating a signal. The behavior of 
the BREAK key depends on other bits in the tty driver that are not set by curses.
.end
